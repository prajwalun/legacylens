// Markdown roadmap generator
import type { Finding, Severity } from '@/types';
import { getSeverityEmoji, getETALabel, getCategoryEmoji } from './scoring';

/**
 * Generate a complete markdown roadmap from findings
 */
export function generateRoadmap(findings: Finding[], repoUrl: string): string {
  const date = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
  const repoName = repoUrl.split('/').slice(-2).join('/');
  
  // Group by severity
  const critical = findings.filter(f => f.severity === 'critical');
  const high = findings.filter(f => f.severity === 'high');
  const medium = findings.filter(f => f.severity === 'medium');
  const low = findings.filter(f => f.severity === 'low');
  
  let markdown = '';
  
  // Header
  markdown += `# ðŸ”® Refactor Roadmap - ${repoName}\n\n`;
  markdown += `*Generated by LegacyLens on ${date}*\n\n`;
  markdown += `> See your code's future. Fix it now.\n\n`;
  markdown += `---\n\n`;
  
  // Executive Summary
  markdown += `## ðŸ“Š Executive Summary\n\n`;
  markdown += generateSummaryTable(findings);
  markdown += `\n---\n\n`;
  
  // Quick Wins Section
  const quickWins = findings
    .filter(f => f.eta === 'easy' && (f.severity === 'critical' || f.severity === 'high'))
    .slice(0, 5);
  
  if (quickWins.length > 0) {
    markdown += `## âš¡ Quick Wins (Start Here!)\n\n`;
    markdown += `These issues are both high-impact and easy to fix. Perfect starting point!\n\n`;
    quickWins.forEach((finding, index) => {
      markdown += `${index + 1}. **${finding.title}** - \`${finding.file}:${finding.line}\` (${getETALabel(finding.eta)})\n`;
    });
    markdown += `\n---\n\n`;
  }
  
  // Detailed sections by severity
  if (critical.length > 0) {
    markdown += generateSeveritySection('Critical', critical, 'ðŸ”´');
  }
  if (high.length > 0) {
    markdown += generateSeveritySection('High', high, 'âš ï¸');
  }
  if (medium.length > 0) {
    markdown += generateSeveritySection('Medium', medium, 'ðŸŸ¡');
  }
  if (low.length > 0) {
    markdown += generateSeveritySection('Low', low, 'ðŸ”µ');
  }
  
  // Implementation Guide
  markdown += `## ðŸ“‹ Implementation Guide\n\n`;
  markdown += generateImplementationGuide();
  markdown += `\n---\n\n`;
  
  // Footer
  markdown += `## ðŸŽ¯ Next Steps\n\n`;
  markdown += `1. **Prioritize:** Start with Quick Wins and Critical issues\n`;
  markdown += `2. **Track:** Create GitHub issues for each finding\n`;
  markdown += `3. **Fix:** Follow the fix suggestions provided\n`;
  markdown += `4. **Verify:** Run tests after each fix\n`;
  markdown += `5. **Monitor:** Re-scan periodically to track progress\n\n`;
  markdown += `---\n\n`;
  markdown += `*ðŸ”® Generated by [LegacyLens](https://legacylens.dev) - AI-powered code analysis*\n`;
  
  return markdown;
}

/**
 * Generate summary statistics table
 */
function generateSummaryTable(findings: Finding[]): string {
  const totalTime = findings.reduce((sum, f) => sum + f.minutesSaved, 0);
  const totalHours = Math.round(totalTime / 60 * 10) / 10;
  
  const criticalCount = findings.filter(f => f.severity === 'critical').length;
  const highCount = findings.filter(f => f.severity === 'high').length;
  const mediumCount = findings.filter(f => f.severity === 'medium').length;
  const lowCount = findings.filter(f => f.severity === 'low').length;
  
  const securityCount = findings.filter(f => f.category === 'security').length;
  const reliabilityCount = findings.filter(f => f.category === 'reliability').length;
  const maintainabilityCount = findings.filter(f => f.category === 'maintainability').length;
  
  let table = '';
  table += `| Metric | Value |\n`;
  table += `|--------|-------|\n`;
  table += `| **Total Issues** | ${findings.length} |\n`;
  table += `| ðŸ”´ Critical | ${criticalCount} |\n`;
  table += `| âš ï¸ High | ${highCount} |\n`;
  table += `| ðŸŸ¡ Medium | ${mediumCount} |\n`;
  table += `| ðŸ”µ Low | ${lowCount} |\n`;
  table += `| **Time Saved** | ${totalHours} hours |\n`;
  table += `| ðŸ”’ Security | ${securityCount} |\n`;
  table += `| âš¡ Reliability | ${reliabilityCount} |\n`;
  table += `| ðŸ”§ Maintainability | ${maintainabilityCount} |\n`;
  
  return table;
}

/**
 * Generate a section for a specific severity level
 */
function generateSeveritySection(
  label: string,
  findings: Finding[],
  emoji: string
): string {
  const totalTime = findings.reduce((sum, f) => sum + f.minutesSaved, 0);
  const totalHours = Math.round(totalTime / 60 * 10) / 10;
  
  let section = `## ${emoji} ${label} Priority\n\n`;
  section += `**${findings.length} issues** Â· **${totalHours} hours** time saved\n\n`;
  
  findings.forEach((finding, index) => {
    section += `### ${index + 1}. ${finding.title}\n\n`;
    
    // Metadata table
    section += `| Property | Value |\n`;
    section += `|----------|-------|\n`;
    section += `| **Location** | \`${finding.file}:${finding.line}\` |\n`;
    section += `| **Severity** | ${getSeverityEmoji(finding.severity)} ${label} |\n`;
    section += `| **Effort** | ${getETALabel(finding.eta)} |\n`;
    section += `| **Category** | ${getCategoryEmoji(finding.category)} ${finding.category} |\n`;
    section += `| **Time Saved** | ${finding.minutesSaved} minutes |\n\n`;
    
    // Explanation
    section += `**Why it matters:**\n\n`;
    section += `${finding.explanation}\n\n`;
    
    // Current code
    section += `**Current code:**\n\n`;
    section += `\`\`\`\n${finding.snippet}\n\`\`\`\n\n`;
    
    // Fix
    section += `**Recommended fix:**\n\n`;
    section += `\`\`\`\n${finding.fix}\n\`\`\`\n\n`;
    
    // Timeline
    section += `**ðŸ”® Future Pain Timeline:**\n\n`;
    section += `- **3 months:** ${finding.timeline.t3m}\n`;
    section += `- **6 months:** ${finding.timeline.t6m}\n`;
    section += `- **1 year:** ${finding.timeline.t1y}\n`;
    section += `- **2 years:** ${finding.timeline.t2y}\n\n`;
    
    section += `---\n\n`;
  });
  
  return section;
}

/**
 * Generate implementation guide
 */
function generateImplementationGuide(): string {
  let guide = '';
  
  guide += `### ðŸš€ How to Use This Roadmap\n\n`;
  
  guide += `**1. Start with Quick Wins**\n`;
  guide += `   - Look for issues marked as "â‰¤15 min" with Critical/High severity\n`;
  guide += `   - These provide maximum impact with minimum effort\n\n`;
  
  guide += `**2. Work by Severity**\n`;
  guide += `   - Address Critical issues first\n`;
  guide += `   - Then High, Medium, and Low\n`;
  guide += `   - Each section is sorted by priority\n\n`;
  
  guide += `**3. Group Related Fixes**\n`;
  guide += `   - Fix similar issues together (e.g., all hardcoded secrets)\n`;
  guide += `   - This is more efficient than jumping between different types\n\n`;
  
  guide += `**4. Test After Each Fix**\n`;
  guide += `   - Run your test suite after each change\n`;
  guide += `   - Verify the fix doesn't break existing functionality\n\n`;
  
  guide += `**5. Track Progress**\n`;
  guide += `   - Create GitHub issues for each finding\n`;
  guide += `   - Link them to this roadmap for context\n`;
  guide += `   - Close issues as you fix them\n\n`;
  
  guide += `### ðŸ’¡ Tips for Success\n\n`;
  
  guide += `- **Don't tackle everything at once** - Pick 3-5 issues per sprint\n`;
  guide += `- **Communicate with your team** - Share the roadmap and get buy-in\n`;
  guide += `- **Document your changes** - Update comments and docs as you fix issues\n`;
  guide += `- **Re-scan periodically** - Run LegacyLens again to track progress\n`;
  guide += `- **Celebrate wins** - Each fix reduces future pain!\n`;
  
  return guide;
}

/**
 * Generate a simple checklist version (for GitHub issues)
 */
export function generateChecklist(findings: Finding[]): string {
  const grouped = {
    critical: findings.filter(f => f.severity === 'critical'),
    high: findings.filter(f => f.severity === 'high'),
    medium: findings.filter(f => f.severity === 'medium'),
    low: findings.filter(f => f.severity === 'low'),
  };
  
  let checklist = `# Refactor Checklist\n\n`;
  
  Object.entries(grouped).forEach(([severity, items]) => {
    if (items.length > 0) {
      const emoji = getSeverityEmoji(severity as Severity);
      checklist += `## ${emoji} ${severity.toUpperCase()} (${items.length})\n\n`;
      
      items.forEach(finding => {
        checklist += `- [ ] ${finding.title} - \`${finding.file}:${finding.line}\`\n`;
      });
      
      checklist += `\n`;
    }
  });
  
  return checklist;
}

/**
 * Generate a CSV export of findings (for spreadsheets)
 */
export function generateCSV(findings: Finding[]): string {
  let csv = 'Severity,Category,Title,File,Line,ETA,Minutes Saved,3mo,6mo,1yr,2yr\n';
  
  findings.forEach(f => {
    const row = [
      f.severity,
      f.category,
      `"${f.title.replace(/"/g, '""')}"`,
      f.file,
      f.line,
      f.eta,
      f.minutesSaved,
      `"${f.timeline.t3m.replace(/"/g, '""')}"`,
      `"${f.timeline.t6m.replace(/"/g, '""')}"`,
      `"${f.timeline.t1y.replace(/"/g, '""')}"`,
      `"${f.timeline.t2y.replace(/"/g, '""')}"`,
    ];
    csv += row.join(',') + '\n';
  });
  
  return csv;
}

/**
 * Generate JSON export of findings
 */
export function generateJSON(findings: Finding[], repoUrl: string): string {
  const data = {
    repository: repoUrl,
    generatedAt: new Date().toISOString(),
    totalFindings: findings.length,
    findings: findings,
  };
  
  return JSON.stringify(data, null, 2);
}

